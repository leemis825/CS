<details>
<summary><strong>스택(Stack) & 큐(Queue)</strong></summary>
# 스택(Stack) & 큐(Queue) 자료구조 정리

## 1. 개념 요약

### 스택 (Stack)
- 후입선출(LIFO, Last In First Out) 구조
- 데이터의 삽입(push)과 삭제(pop)이 한쪽 끝(top)에서만 이루어짐
- 가장 마지막에 들어온 데이터가 가장 먼저 나감

### 큐 (Queue)
- 선입선출(FIFO, First In First Out) 구조
- 데이터의 삽입(enqueue)은 뒤(rear), 삭제(dequeue)는 앞(front)에서 이루어짐
- 먼저 들어온 데이터가 먼저 처리됨

---

## 2. 시간 복잡도 비교

| 연산 | 스택 | 큐 |
|------|------|-----|
| 삽입 | O(1) | O(1) |
| 삭제 | O(1) | O(1) |
| 탐색 | O(n) | O(n) |

※ 단, 배열 기반 큐에서 맨 앞 요소 삭제 시에는 O(n) 시간 소요 → 덱(deque) 구조로 보완

---

## 3. 삽입/삭제 위치와 자료구조 선택 기준

자료구조는 다음과 같은 기준으로 선택한다.

| 데이터 처리 위치 | 적절한 자료구조 | 설명 |
|------------------|------------------|------|
| 마지막(top)만 자주 다룸 | Stack | 뒤로 가기, 함수 호출 스택 등 |
| 처음부터 순서대로 처리 | Queue | 요청 대기열, BFS 탐색 등 |
| 중간 삽입/삭제 자주 발생 | Linked List | 포인터만 조정하면 되므로 효율적 |
| 빠른 탐색이 중요 | Tree / HashMap | 검색 속도 빠름 (O(log n) 또는 O(1)) |

---

## 4. 실무 적용 예시

### 스택
- 웹 브라우저 '뒤로 가기' 기능
- 함수 호출(재귀 구조 → 콜 스택)
- 화면 전환 (예: Flutter의 Navigator.push/pop)

### 큐
- 프린터 요청 처리
- 메시지 처리 시스템
- BFS(너비 우선 탐색) 구현
- 사용자 입력 처리 순서

---

## 5. 실제 프로젝트에서의 적용

| 기능 | 구조 개념 | 설명 |
|------|-----------|------|
| Flutter 화면 전환 (Navigator.push/pop) | Stack | 가장 마지막에 연 화면부터 pop하여 되돌아감 |
| Firebase 출석 처리 기록 | Queue | 먼저 찍은 출석부터 순차 처리 및 정렬 필요 |
| 재귀 기반 DFS 구현 | Stack | 호출이 스택에 쌓이며 후입선출 방식으로 탐색 수행 |

---

## 6. 결론 및 인사이트

- 자료구조는 단순히 외워서 쓰는 것이 아니라, 데이터가 어떻게 흐르고 어떤 위치에서 다뤄지는지를 기준으로 선택하는 것이 핵심이다.
- 삽입/삭제 위치와 시간 복잡도는 실무에서 코드 성능과 직결되며, 자료구조 선택의 근거가 된다.
- 실제 프로젝트를 통해 알게 모르게 스택과 큐 구조를 사용해왔으며, 이를 의식하고 구조적으로 설계하는 것이 더 나은 개발로 이어진다.

<details>
<summary><strong>Hash & Hash Table 정리</strong></summary>

## Hash & Hash Table

### 핵심 개념

- **해시 함수(Hash Function)**: 입력값을 고정된 길이의 해시값으로 변환하는 함수. (`SHA256`, `MD5`, `bcrypt` 등)
- **해시 테이블(Hash Table)**: 키를 해시값으로 변환하여 데이터를 빠르게 저장/조회하는 자료구조.
- 일반적으로 평균 시간복잡도는 **O(1)** 이며, 해시 충돌 시에는 **체이닝, 오픈 어드레싱** 등의 방식으로 해결.

---

### 실무 적용 예시

| 실무 분야 | 활용 방식 |
|-----------|------------|
| 로그인 시스템 | 비밀번호 해시 저장 (`bcrypt`, `PBKDF2`, `Argon2`) |
| 캐시 시스템 | API 응답을 해시 키로 캐싱 (`Redis`, `Memcached`) |
| Git / 버전 관리 | 커밋 해시로 버전 추적 및 변경 방지 (`SHA-1`) |
| 블록체인 | 블록 연결 및 무결성 보장 (`SHA-256`) |
| 웹 인증 | JWT 토큰 서명 (`HMAC + SHA256`) |
| 파일 무결성 검사 | 다운로드 후 해시 일치 확인 (`sha256sum`) |

---

### 면접 포인트

- **Q. 해시 테이블의 시간복잡도는?**
  - 평균: O(1), 최악: O(n) (충돌 시)

- **Q. 해시 충돌이란?**
  - 서로 다른 키가 동일한 해시값을 가질 때 발생.  
    해결 방법으로는 **체이닝(연결 리스트)** 또는 **오픈 어드레싱(빈 공간 탐색)** 사용.

- **Q. 해시 함수는 왜 단방향이어야 하는가?**
  - 보안을 위해. 해시값으로 원래 데이터를 복원할 수 없도록 설계됨.

- **Q. SHA256과 bcrypt 차이는?**
  - SHA256: 빠르지만 보안에 취약 (무작위 대입 공격 가능)  
  - bcrypt: 느리지만 안전, salt를 내부에 포함하고 반복 횟수 조절 가능

---

### 코드 예시 (Python)

# 일반 해시 사용
# import hashlib
# h = hashlib.sha256(b"mypassword").hexdigest()
# print(h)  # 같은 입력이면 항상 같은 해시 출력

# Salt 사용 예시
# import os
# salt = os.urandom(16)
# hashed = hashlib.pbkdf2_hmac('sha256', b"mypassword", salt, 100000)
# print(hashed)

---

